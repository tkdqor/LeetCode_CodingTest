/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode node = new ListNode(0); // 1. 결과 연결 리스트의 더미 헤드 노드를 생성합니다. 이는 결과 리스트의 시작을 쉽게 다루기 위함입니다.
        ListNode result = node;          // 2. 결과 리스트의 실제 시작점을 나중에 반환하기 위해 더미 헤드를 가리키는 포인터 'result'를 저장합니다.
        int sum = 0;                     // 3. 현재 자릿수의 합과 다음 자릿수로 넘어갈 올림(carry) 값을 저장할 변수 'sum'을 0으로 초기화합니다.

        while (l1 != null || l2 != null || sum > 0) { // 4. l1, l2 둘 중 하나라도 남았거나, 마지막에 올림(carry) 값이 남아있으면 루프를 계속합니다.
            if (l1 != null) {            // 5. 첫 번째 숫자 리스트(l1)가 아직 끝나지 않았다면,
                sum += l1.val;           //    현재 l1 노드의 값을 'sum'에 더합니다.
                l1 = l1.next;            //    l1 포인터를 다음 노드로 이동시켜 다음 자릿수를 처리할 준비를 합니다.
            }

            if (l2 != null) {            // 6. 두 번째 숫자 리스트(l2)가 아직 끝나지 않았다면,
                sum += l2.val;           //    현재 l2 노드의 값을 'sum'에 더합니다.
                l2 = l2.next;            //    l2 포인터를 다음 노드로 이동시켜 다음 자릿수를 처리할 준비를 합니다.
            }

            node.next = new ListNode(sum % 10); // 7. 현재 자릿수의 합('sum')을 10으로 나눈 나머지(sum % 10)는 현재 자릿수의 값입니다.
                                             //    이 값을 가진 새로운 노드를 생성하여 'node'가 현재 가리키는 노드의 'next'에 연결합니다.
                                             //    (예: sum이 15이면 5가 현재 자릿수 값)
            sum /= 10;                       // 8. 현재 자릿수의 합('sum')을 10으로 나눈 몫(sum / 10)은 다음 자릿수로 넘어갈 올림(carry) 값입니다.
                                             //    이 값을 'sum'에 저장하여 다음 루프에서 사용합니다.
                                             //    (예: sum이 15이면 1이 다음 자릿수로 넘어감)

            node = node.next;                // 9. 'node' 포인터를 새로 생성된 노드(node.next)로 이동시킵니다.
                                             //    이는 다음 자릿수의 노드를 연결할 준비를 하기 위함입니다.
        }

        return result.next;              // 10. 'result'는 더미 헤드 노드('node = new ListNode(0)')를 가리키고 있었으므로,
                                         //     실제 결과 리스트의 시작은 더미 헤드의 다음 노드('result.next')입니다.
                                         //     이것을 반환합니다.
    }
}




// 네, 해당 줄의 의미를 좀 더 명확하게 이해할 수 있도록 구체적인 예시를 들어 설명해 드릴게요.
// 문제는 두 숫자를 더하는 것입니다. 각 숫자는 연결 리스트에 역순으로 저장되어 있습니다. 
// 예를 들어, 숫자 342는 2 -> 4 -> 3으로, 숫자 465는 5 -> 6 -> 4로 표현됩니다.
// 우리는 이 두 리스트를 마치 초등학교 때 세로로 숫자를 더하는 것처럼 가장 낮은 자릿수(일의 자리)부터 차례대로 더해 나갑니다. 
// 이때, 각 자릿수의 합이 10이 넘어가면 올림(carry)이 발생합니다.

    
// 예시: 2 -> 4 -> 3 (숫자 342) 와 5 -> 6 -> 4 (숫자 465) 더하기
    
// 1단계: 일의 자리 (첫 번째 노드) 더하기
// l1.val = 2
// l2.val = 5
// sum (이전 자릿수에서 넘어온 올림, 초기값 0) = 0
// sum += l1.val; => sum은 0 + 2 = 2가 됩니다.
// sum += l2.val; => sum은 2 + 5 = 7이 됩니다.
// 이제 sum은 7입니다.
// 여기서 문제의 문장 적용:
// node.next = new ListNode(sum % 10);
// sum (7)을 10으로 나눈 나머지 (7 % 10)는 7입니다.
// 따라서 새로운 노드에는 7이 저장되고, 이 7이 바로 두 숫자의 일의 자리 합인 7이 됩니다.
// sum /= 10; => sum (7)을 10으로 나눈 몫 (7 / 10)은 0입니다. (정수 나눗셈)
// 이 0은 다음 자릿수로 넘어갈 올림 값입니다. 현재는 올림이 없습니다.

    
// 2단계: 십의 자리 (두 번째 노드) 더하기
// l1.val = 4
// l2.val = 6
// sum (이전 자릿수에서 넘어온 올림) = 0 (1단계에서 계산된 올림)
// sum += l1.val; => sum은 0 + 4 = 4가 됩니다.
// sum += l2.val; => sum은 4 + 6 = 10이 됩니다.
// 이제 sum은 10입니다.
// 여기서 문제의 문장 적용:
// node.next = new ListNode(sum % 10);
// sum (10)을 10으로 나눈 나머지 (10 % 10)는 0입니다.
// 따라서 새로운 노드에는 0이 저장됩니다. 이 0이 바로 두 숫자의 십의 자리 합인 0이 됩니다. (342 + 465 = 807, 십의 자리는 0이죠)
// sum /= 10; => sum (10)을 10으로 나눈 몫 (10 / 10)은 1입니다.
// 이 1은 다음 자릿수(백의 자리)로 넘어갈 올림 값입니다.

    
// 3단계: 백의 자리 (세 번째 노드) 더하기
// l1.val = 3
// l2.val = 4
// sum (이전 자릿수에서 넘어온 올림) = 1 (2단계에서 계산된 올림)
// sum += l1.val; => sum은 1 + 3 = 4가 됩니다.
// sum += l2.val; => sum은 4 + 4 = 8이 됩니다.
// 이제 sum은 8입니다.
// 여기서 문제의 문장 적용:
// node.next = new ListNode(sum % 10);
// sum (8)을 10으로 나눈 나머지 (8 % 10)는 8입니다.
// 따라서 새로운 노드에는 8이 저장됩니다. 이 8이 바로 두 숫자의 백의 자리 합인 8이 됩니다.
// sum /= 10; => sum (8)을 10으로 나눈 몫 (8 / 10)은 0입니다.
// 이 0은 다음 자릿수로 넘어갈 올림 값입니다.

    
// 보시다시피, sum % 10은 현재 자릿수의 합이 얼마가 되든 상관없이 그 합의 일의 자리 숫자를 정확히 뽑아내어 현재 노드의 값으로 사용합니다. 
// 그리고 sum /= 10은 나머지 (올림 값)를 다음 자릿수 계산을 위해 sum 변수에 저장하는 역할을 합니다. 이 두 연산이 함께 작동하여 십진수 덧셈의 원리를 구현하는 것입니다.
